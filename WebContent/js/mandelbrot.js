/**
 * 
 */
$(function() {
    $('#drawMandelbrotButton').click(draw_Mandelbrot);
    $('#selectMandelbrotRegionButton').click(selectMandelbrotRegion);
    
    //Create the logger
	log = log4javascript.getDefaultLogger();

});

function draw_Mandelbrot(){
	var canvas,
	    ctx,
	    config = {},
	    formValues = {},
	    $inputs = [];

	
	config.canvas = document.getElementById('mandelbrot');
	if (config.canvas.getContext) {
		//Get an image data object
		config.ctx = config.canvas.getContext('2d');
		//config.canvas = {};
	    config.canvas.width = jQuery('#mandelbrot').width();
	    config.canvas.height = jQuery('#mandelbrot').height();
	    config.imageData = config.ctx.createImageData(config.canvas.width, config.canvas.height);
		config.ctx.putImageData(config.imageData, 0, 0);
	    
	    //Get the operational parameters
	    formValues = {};
	    $inputs = jQuery('#collectConfigurationSettingsForm :input');
	    $inputs.each(function() {
	        formValues[this.name] = jQuery(this).val();
	    });
	    
	    //Debug
	    //console.log("Complex Region Center: (" + formValues.complexRegionCenterR + ',' + formValues.complexRegionCenterI + ')');
	    //console.log("Complex Region Rectangle: (" + formValues.complexRegionWidth + ',' + formValues.complexRegionHeight + ')');
	    //console.log("Iterations: " + formValues.iterations);
		
		//Set the operating parameters. Eventually we will make them configurable
		config.complexRegion = {};
		config.complexRegion.center = {};
		config.complexRegion.center.r = parseFloat(formValues.complexRegionCenterR);
		config.complexRegion.center.i = parseFloat(formValues.complexRegionCenterI);
		config.complexRegion.width = parseFloat(formValues.complexRegionWidth);
		config.complexRegion.height = parseFloat(formValues.complexRegionHeight);
		config.iterations =parseInt( formValues.iterations);
		drawMBS (config);
	}
	
}
/**
 * The Mandelbrot Set
 * It is a mathematical set of points in the complex plane, the boundary of which
 * forms a fractal.  
 * 
 * The Mandelbrot set is the set of complex values of c for which the orbit of 0 
 * under iteration of the complex quadratic polynomial zn' = zn**2 + c remains bounded.
 * That is, a complex number, c, is in the Mandelbrot set if, when starting with 
 * z0 = 0 and applying the iteration repeatedly, the absolute value of zn never 
 * exceeds a certain number (that number depends on c) however large n gets. 
 * 
 * For example, letting c = 1 gives the sequence 0, 1, 2, 5, 26,_, which tends to 
 * infinity. As this sequence is unbounded, 1 is not an element of the Mandelbrot 
 * set. 
 * 
 * On the other hand, c = i (where i is defined as i2 = −1) gives the sequence 0, 
 * i, (−1 + i), −i, (−1 + i), −i, ..., which is bounded and so i belongs to the 
 * Mandelbrot set.
 * 
 * When computed and graphed on the complex plane the Mandelbrot set is seen to 
 * have an elaborate boundary which, being a fractal, does not simplify at any given 
 * magnification.The Mandelbrot set has become popular outside mathematics both 
 * for its aesthetic appeal and for being a complicated structure arising from a 
 * simple definition, and is one of the best-known examples of mathematical visualization. 
 * 
 * Mathematically, the Mandelbrot set is just a set of complex numbers. A given 
 * complex number c either belongs to M or it does not. A picture of the Mandelbrot 
 * set can be made by colouring all the points c which belong to M black, and all 
 * other points white. The more colourful pictures usually seen are generated by 
 * colouring points not in the set according to how quickly or slowly the sequence
 * diverges to infinity
 * 
 * What is the point of writing another yet another program to graph the Mandelbrot set
 * This article chronicles an my experience in writing a software program to graph
 * the Medelbrot set. There are countless documented examples of such attempts; therefore
 * I do not plan to break any new ground, except to do something I enjoy quite a bit
 * which is to write software while exploring new technologies.In this particular 
 * case my goal is to write this program using the new HTML 5 Canvas element.
 * 
 * The solution
 * The essence of this solution lies in dealing two distinct spaces
 * - The complex numbers being assessed for M/S membership
 * - The drawing canvas being used to represent these numbers M/S membership. Members 
 *   are rendered in black. Non members are rendered in color. The color used to 
 *   render non-members correlates to the number of iterations required to assess
 *   membership
 * 
 *   The complex numbers
 *   Graphing the Medelbrot set amounts to selecting a complex number region and
 *   assessing the complex numbers in it for membership in the Mandelbrot set. For 
 *   practical purposes we will define this region as a rectangle, as follows:
 *   - center (iCenter): the center of the square containing the complex numbers
 *   - height (iHeight): the height of the rectangle
 *   - width (iWidth): the width of the rectangle
 *   Therefore, the complex numbers under consideration fit in to the following square
 *   - NW = x = iCenter.x - iWidth/2, y = iCenter.x + iHeight/2
 *   - NE = x = iCenter.x + iWidth/2, y = iCenter.x + iHeight/2
 *   - SE = x = iCenter.x + iWidth/2, y = iCenter.x - iHeight/2
 *   - SW = x = iCenter.x - iWidth/2, y = iCenter.x - iHeight/2
 *   
 *   The drawing canvas
 *   The graphing will be rendered onto a computer screen. The screen area used
 *   build the graph is called a canvas and, not surprisingly, will be a rectangle,
 *   described as follows:
 *   - selector (cSelector): the id of the HMTL canvas object. Since the complex 
 *     set we are drawing fits within a square, our canvas is also a square. All
 *     the canvas coordinates are based on it NW corner
 *   - height (cHeight): the height of the canvas
 *   - width (cWidth): the width of the canvas
 *   Therefore, the canvas used to represent the complex numbers under consideration 
 *   fit in to the following square
 *   - NW = x = 0      , y = 0  
 *   - NE = x = cWidth , y = 0
 *   - SE = x = cWidth,  y = cHeight
 *   - SW = x = 0     ,  y = cHeight
 *   
 *   Sampling the complex numbers
 *   The quantity of complex numbers within any regions is infinite whereas the 
 *   number of pixels in the canvas where their M/S membership is graphed is finite. 
 *   This requires a mechanism to select and render a subset of the complex numbers 
 *   under consideration. The  complex numbers will be selected based on the proportion 
 *   between their square height and width and that of the canvas square. Given
 *   a selected complex number c = m + in, (m, n in R), c', the next complex number
 *   to be considered will be c' = (m + xStep) + i(n + yStep) where
 *   - xStep = iWidth/cWidth
 *   - yStep = iHeight/cHeigth
 *   
 *   Assessing membership
 *   It has been demonstrated that if the absolute value of an iteration exceeds
 *   2 the seed complex number does not belong to the M/S; thus, when assesssnig
 *   membership of a complex number c, if at a given iteration the absolute value 
 *   of c', one of the iteration terms,   exceeds 2, c will be assessed as not being
 *   a member.
 *   
 *   The only remaining item for consideration is the number of c' to be considered
 *   before a complex number c M/S membership is granted. I have no idea at the moment
 *   and will use a random number; I envision learning about it experimentaly; perhaps 
 *   using a iterative method where, given a set of complex numbers, starting 
 *   with a certain number of iterations and measuring the number of c that are
 *   in the M/S, we increase the number of iterations and compare the quantity
 *   of c, q, in the M/S; once q stabilizes, we know we have an acceptable i
 */
function drawMBS (config) {
	var ImageHeight = config.canvas.height, //200
	    ImageWidth = config.canvas.width, //300
	    MinRe = -2.0,
	    MaxRe = 1.0, 
	    MinIm = -1.2,
	    MaxIm = MinIm+(MaxRe-MinRe)*ImageHeight/ImageWidth,
	    Re_factor = (MaxRe-MinRe)/(ImageWidth-1),
	    Im_factor = (MaxIm-MinIm)/(ImageHeight-1),
	    MaxIterations = config.iterations,
	    imageData = config.imageData,
	    pixelAddress = 0;
	    
	// Map n to a color so that from 0 to MaxIterations/2-1 the color goes from 
	// black to red and from MaxIterations/2 to MaxIterations-1  the color goes 
	// from red to white
	var colorMap = [[0,0,0]];
	colorIndex = 1;
	while (colorIndex < Math.floor(MaxIterations/2)) {
		var thisMap = [];
		thisMap = [Math.floor(255*colorIndex/(MaxIterations/2)), 0, 0];
		colorMap.push(thisMap);
		colorIndex++;
	}
	while (colorIndex < Math.floor(MaxIterations)) {
		var thisMap = [];
		thisMap = [255, Math.floor(255*colorIndex/MaxIterations), Math.floor(255*colorIndex/MaxIterations)];
		colorMap.push(thisMap);
		colorIndex++;
	}
	
	//Debug
	console.log('Iterations: ' + MaxIterations);
	console.log('Canvas Rectangle: (' + config.canvas.width + ' x ' + config.canvas.height + ')');
	console.log('Complex Rectangle: NW = (' + MinRe + ', ' + MaxIm + '), SE = (' + MaxRe + ', ' + MinIm + ')');
	console.log('Complex Steps: Re-factor = ' + Re_factor + ', Im_factor =' + Im_factor );
	
	//A pixel address in the array is given by the following formula
	// pixelAddr = row*width*4 + column*4
	console.log('C = (' + MinRe + ', ' + MaxIm +')');
	for (var y = 0; y < ImageHeight; ++y) {
		var c_im = MaxIm - y*Im_factor; 
		for(var x = 0; x < ImageWidth; ++x) {
			var c_re = MinRe + x*Re_factor;
			//if  (y < 2) {
				//console.log('C = (' + c_re + ', ' + c_im +')');
			//}
			var Z_re = c_re; 
			var Z_im = c_im; 
			var isInside = true; 
			for(var n = 0; n < MaxIterations; ++n) {
				var Z_re2 = Z_re*Z_re;
				var Z_im2 = Z_im*Z_im; 
				if(Z_re2 + Z_im2 > 4) {
					isInside = false; 
					break;
				} 
				Z_im = 2*Z_re*Z_im + c_im; 
				Z_re = Z_re2 - Z_im2 + c_re;
			} 
			
			if  (y < 2) {
				console.log('XY = (' +  x + ', ' + y + ') - pixelAddr = ' + pixelAddress);
			}
			if (!isInside) {
				//The complex number does no belong to the Mandelbrot set
				/*
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 255;
				*/
				imageData.data[pixelAddress++] = colorMap[n][0];
				imageData.data[pixelAddress++] = colorMap[n][1];
				imageData.data[pixelAddress++] = colorMap[n][2];
				imageData.data[pixelAddress++] = 255;
			}
			else {
				pixelAddress += 4;				
				//imageData.data[pixelAddress++] = 0;
				//imageData.data[pixelAddress++] = 0;
				//imageData.data[pixelAddress++] = 0;
				//imageData.data[pixelAddress++] = 0;
			}
		}
	}
	console.log('C = (' + c_re + ', ' + c_im +')');
	config.ctx.putImageData(imageData, 0, 0);
}

function selectMandelbrotRegion() { 
	log.debug('Selecting Mandelbrot Region ');
	
	//Set all canvas regions to have a cross hair cursor
	jQuery('canvas').css('cursor', 'crosshair')
	log.debug('canvas cursor is now crosshair');
	
	jQuery('canvas').mouseover(function (){
		jQuery('canvas').css('cursor', 'crosshair');		
	});
	
	jQuery('canvas').mousemove(function (e){
		jQuery('canvas').css('cursor', 'crosshair');		
	    var pageCoords = "( " + e.pageX + ", " + e.pageY + " )";
	    var clientCoords = "( " + e.clientX + ", " + e.clientY + " )";
	    var offsetCoords = "( " + e.offsetX + ", " + e.offsetY + " )";
	     log.debug("( e.pageX, e.pageY ) - " + pageCoords);
	     log.debug("( e.clientX, e.clientY ) - " + clientCoords);
	     log.debug("( e.offsetX, e.offsetY ) - " + clientCoords);
	     log.debug("Target - " + e.target.id);
	     log.debug("Element Offset - (" + jQuery(e.target).offset().top + ", " +  jQuery(e.target).offset().left + ")");
	});
}