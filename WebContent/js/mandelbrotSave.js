/**
 * 
 */
$(function() {
    $('#drawMandelbrotButton').click(draw_Mandelbrot);
    $('#selectMandelbrotRegionButton').click(selectMandelbrotRegion);
});

function draw_Mandelbrot(){
	var canvas,
	    ctx,
	    config = {},
	    formValues = {},
	    $inputs = [];

	
	config.canvas = document.getElementById('mandelbrot');
	if (config.canvas.getContext) {
		//Get an image data object
		config.ctx = config.canvas.getContext('2d');
		//config.canvas = {};
	    config.canvas.width = jQuery('#mandelbrot').width();
	    config.canvas.height = jQuery('#mandelbrot').height();
	    config.imageData = config.ctx.createImageData(config.canvas.width, config.canvas.height);
		config.ctx.putImageData(config.imageData, 0, 0);
	    
	    //Get the operational parameters
	    formValues = {};
	    $inputs = jQuery('#collectConfigurationSettingsForm :input');
	    $inputs.each(function() {
	        formValues[this.name] = jQuery(this).val();
	    });
	    
	    //Debug
	    //console.log("Complex Region Center: (" + formValues.complexRegionCenterR + ',' + formValues.complexRegionCenterI + ')');
	    //console.log("Complex Region Rectangle: (" + formValues.complexRegionWidth + ',' + formValues.complexRegionHeight + ')');
	    //console.log("Iterations: " + formValues.iterations);
		
		//Set the operating parameters. Eventually we will make them configurable
		config.complexRegion = {};
		config.complexRegion.center = {};
		config.complexRegion.center.r = parseFloat(formValues.complexRegionCenterR);
		config.complexRegion.center.i = parseFloat(formValues.complexRegionCenterI);
		config.complexRegion.width = parseFloat(formValues.complexRegionWidth);
		config.complexRegion.height = parseFloat(formValues.complexRegionHeight);
		config.iterations =parseInt( formValues.iterations);
		//drawMandelbrot(config);
		drawMBS (config);
	}
	
}
/**
 * The Mandelbrot Set
 * It is a mathematical set of points in the complex plane, the boundary of which
 * forms a fractal.  
 * 
 * The Mandelbrot set is the set of complex values of c for which the orbit of 0 
 * under iteration of the complex quadratic polynomial zn' = zn**2 + c remains bounded.
 * That is, a complex number, c, is in the Mandelbrot set if, when starting with 
 * z0 = 0 and applying the iteration repeatedly, the absolute value of zn never 
 * exceeds a certain number (that number depends on c) however large n gets. 
 * 
 * For example, letting c = 1 gives the sequence 0, 1, 2, 5, 26,…, which tends to 
 * infinity. As this sequence is unbounded, 1 is not an element of the Mandelbrot 
 * set. 
 * 
 * On the other hand, c = i (where i is defined as i2 = −1) gives the sequence 0, 
 * i, (−1 + i), −i, (−1 + i), −i, ..., which is bounded and so i belongs to the 
 * Mandelbrot set.
 * 
 * When computed and graphed on the complex plane the Mandelbrot set is seen to 
 * have an elaborate boundary which, being a fractal, does not simplify at any given 
 * magnification.The Mandelbrot set has become popular outside mathematics both 
 * for its aesthetic appeal and for being a complicated structure arising from a 
 * simple definition, and is one of the best-known examples of mathematical visualization. 
 * 
 * Mathematically, the Mandelbrot set is just a set of complex numbers. A given 
 * complex number c either belongs to M or it does not. A picture of the Mandelbrot 
 * set can be made by colouring all the points c which belong to M black, and all 
 * other points white. The more colourful pictures usually seen are generated by 
 * colouring points not in the set according to how quickly or slowly the sequence
 * diverges to infinity
 * 
 * What is the point of writing another yet another program to graph the Mandelbrot set
 * This article chronicles an my experience in writing a software program to graph
 * the Medelbrot set. There are countless documented examples of such attempts; therefore
 * I do not plan to break any new ground, except to do something I enjoy quite a bit
 * which is to write software while exploring new technologies.In this particular 
 * case my goal is to write this program using the new HTML 5 Canvas element.
 * 
 * The solution
 * The essence of this solution lies in dealing two distinct spaces
 * - The complex numbers being assessed for M/S membership
 * - The drawing canvas being used to represent these numbers M/S membership. Members 
 *   are rendered in black. Non members are rendered in color. The color used to 
 *   render non-members correlates to the number of iterations required to assess
 *   membership
 * 
 *   The complex numbers
 *   Graphing the Medelbrot set amounts to selecting a complex number region and
 *   assessing the complex numbers in it for membership in the Mandelbrot set. For 
 *   practical purposes we will define this region as a rectangle, as follows:
 *   - center (iCenter): the center of the square containing the complex numbers
 *   - height (iHeight): the height of the rectangle
 *   - width (iWidth): the width of the rectangle
 *   Therefore, the complex numbers under consideration fit in to the following square
 *   - NW = x = iCenter.x - iWidth/2, y = iCenter.x + iHeight/2
 *   - NE = x = iCenter.x + iWidth/2, y = iCenter.x + iHeight/2
 *   - SE = x = iCenter.x + iWidth/2, y = iCenter.x - iHeight/2
 *   - SW = x = iCenter.x - iWidth/2, y = iCenter.x - iHeight/2
 *   
 *   The drawing canvas
 *   The graphing will be rendered onto a computer screen. The screen area used
 *   build the graph is called a canvas and, not surprisingly, will be a rectangle,
 *   described as follows:
 *   - selector (cSelector): the id of the HMTL canvas object. Since the complex 
 *     set we are drawing fits within a square, our canvas is also a square. All
 *     the canvas coordinates are based on it NW corner
 *   - height (cHeight): the height of the canvas
 *   - width (cWidth): the width of the canvas
 *   Therefore, the canvas used to represent the complex numbers under consideration 
 *   fit in to the following square
 *   - NW = x = 0      , y = 0  
 *   - NE = x = cWidth , y = 0
 *   - SE = x = cWidth,  y = cHeight
 *   - SW = x = 0     ,  y = cHeight
 *   
 *   Sampling the complex numbers
 *   The quantity of complex numbers within any regions is infinite whereas the 
 *   number of pixels in the canvas where their M/S membership is graphed is finite. 
 *   This requires a mechanism to select and render a subset of the complex numbers 
 *   under consideration. The  complex numbers will be selected based on the proportion 
 *   between their square height and width and that of the canvas square. Given
 *   a selected complex number c = m + in, (m, n in R), c', the next complex number
 *   to be considered will be c' = (m + xStep) + i(n + yStep) where
 *   - xStep = iWidth/cWidth
 *   - yStep = iHeight/cHeigth
 *   
 *   Assessing membership
 *   It has been demonstrated that if the absolute value of an iteration exceeds
 *   2 the seed complex number does not belong to the M/S; thus, when assesssnig
 *   membership of a complex number c, if at a given iteration the absolute value 
 *   of c', one of the iteration terms,   exceeds 2, c will be assessed as not being
 *   a member.
 *   
 *   The only remaining item for consideration is the number of c' to be considered
 *   before a complex number c M/S membership is granted. I have no idea at the moment
 *   and will use a random number; I envision learning about it experimentaly; perhaps 
 *   using a iterative method where, given a set of complex numbers, starting 
 *   with a certain number of iterations and measuring the number of c that are
 *   in the M/S, we increase the number of iterations and compare the quantity
 *   of c, q, in the M/S; once q stabilizes, we know we have an acceptable i
 */
function drawMBS (config) {
	var ImageHeight = config.canvas.height, //200
	    ImageWidth = config.canvas.width, //300
	    MinRe = -2.0,
	    MaxRe = 1.0, 
	    MinIm = -1.2,
	    MaxIm = MinIm+(MaxRe-MinRe)*ImageHeight/ImageWidth,
	    Re_factor = (MaxRe-MinRe)/(ImageWidth-1),
	    Im_factor = (MaxIm-MinIm)/(ImageHeight-1),
	    MaxIterations = config.iterations,
	    imageData = config.imageData,
	    pixelAddress = 0;
	    
	// Map n to a color so that from 0 to MaxIterations/2-1 the color goes from 
	// black to red and from MaxIterations/2 to MaxIterations-1  the color goes 
	// from red to white
	var colorMap = [[0,0,0]];
	colorIndex = 1;
	while (colorIndex < Math.floor(MaxIterations/2)) {
		var thisMap = [];
		thisMap = [Math.floor(255*colorIndex/(MaxIterations/2)), 0, 0];
		colorMap.push(thisMap);
		colorIndex++;
	}
	while (colorIndex < Math.floor(MaxIterations)) {
		var thisMap = [];
		thisMap = [255, Math.floor(255*colorIndex/MaxIterations), Math.floor(255*colorIndex/MaxIterations)];
		colorMap.push(thisMap);
		colorIndex++;
	}
	
	//Debug
	console.log('Iterations: ' + MaxIterations);
	console.log('Canvas Rectangle: (' + config.canvas.width + ' x ' + config.canvas.height + ')');
	console.log('Complex Rectangle: NW = (' + MinRe + ', ' + MaxIm + '), SE = (' + MaxRe + ', ' + MinIm + ')');
	console.log('Complex Steps: Re-factor = ' + Re_factor + ', Im_factor =' + Im_factor );
	
	//A pixel address in the array is given by the following formula
	// pixelAddr = row*width*4 + column*4
	console.log('C = (' + MinRe + ', ' + MaxIm +')');
	for (var y = 0; y < ImageHeight; ++y) {
		var c_im = MaxIm - y*Im_factor; 
		for(var x = 0; x < ImageWidth; ++x) {
			var c_re = MinRe + x*Re_factor;
			//if  (y < 2) {
				//console.log('C = (' + c_re + ', ' + c_im +')');
			//}
			var Z_re = c_re; 
			var Z_im = c_im; 
			var isInside = true; 
			for(var n = 0; n < MaxIterations; ++n) {
				var Z_re2 = Z_re*Z_re;
				var Z_im2 = Z_im*Z_im; 
				if(Z_re2 + Z_im2 > 4) {
					isInside = false; 
					break;
				} 
				Z_im = 2*Z_re*Z_im + c_im; 
				Z_re = Z_re2 - Z_im2 + c_re;
			} 
			
			if  (y < 2) {
				console.log('XY = (' +  x + ', ' + y + ') - pixelAddr = ' + pixelAddress);
			}
			if (!isInside) {
				//The complex number does no belong to the Mandelbrot set
				/*
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 255;
				*/
				imageData.data[pixelAddress++] = colorMap[n][0];
				imageData.data[pixelAddress++] = colorMap[n][1];
				imageData.data[pixelAddress++] = colorMap[n][2];
				imageData.data[pixelAddress++] = 255;
			}
			else {
				pixelAddress += 4;				
				//imageData.data[pixelAddress++] = 0;
				//imageData.data[pixelAddress++] = 0;
				//imageData.data[pixelAddress++] = 0;
				//imageData.data[pixelAddress++] = 0;
			}
		}
	}
	console.log('C = (' + c_re + ', ' + c_im +')');
	config.ctx.putImageData(imageData, 0, 0);
}

function selectMandelbrotRegion() {
	
}

function drawMandelbrot(config) {
	var i,
	    colorIndex = [],
		rStep,
	    iStep,
	    complex = {},
	    imageData = null,
	    pixelAddress = 0,
	    pixelInSet = false;
	
	//Build a color index array
	for (i = 0; i < config.iterations; i++ ) {
		colorIndex[i] = Math.floor(255/i);
	}
	
	//Compute the steps
	rStep = config.complexRegion.width /  config.canvas.width;
	iStep = config.complexRegion.height /  config.canvas.height;
	console.log ('Steps: (' + rStep + ', ' + iStep + ')');
	
	//Graph the membership of the selected complex region. The number of complex 
	//numbers to be assessed is determined by the number of pixels in the graphing
	//canvas. Starting at the NW corner of the graphing canvas a c is selected by
	//picking the c from the NW corner in the complex region; keep y constant, ...

	//Get the complex number at the NW corner of the complex region
	complex.r = config.complexRegion.center.r - config.complexRegion.width/2;
	complex.i = config.complexRegion.center.i + config.complexRegion.height/2;
	console.log ('NW Complex: (' + complex.r + ', ' + complex.i + ')');

	//Adjust for the loop
	complex.r -= rStep;
	complex.i -= iStep;
    pixelAddress = 0;
    imageData = config.imageData;
	for (var r = 0; r < config.canvas.width; r++ ) {
		complex.r += rStep;
		complex.i = config.complexRegion.center.i + config.complexRegion.height/2 + iStep;
		console.log('Assesing Complex: (' + complex.r + ', ' + complex.i + ')');
		for (i = 0; i < config.canvas.height; i++) {
			complex.i -= iStep;
			
			
			//Assess whether complex belongs to the Mandelbrot set
			zr = 0;
			zi = 0;
			zr2 = 0;
			zi2 = 0;
			pixelInSet = true;
			for (iterations = 0; iterations < config.iterations; iterations++) {
				zr2 = zr*zr;
				zi2 = zi*zi;
				if (zr2 + zi2 >= 4) {
					//Pixel not in set
					pixelInSet = false;
					break;
				}
				zr  = zr2-zi2 + complex.r;
				zi  = 2*zr*zi + complex.i;
			}
			if (!pixelInSet) {
				//The complex number does belongs to the Mandelbrot set
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 0;
				imageData.data[pixelAddress++] = 255;
			}
			else {
				pixelAddress += 4;				
			}
		}
	}
	config.ctx.putImageData(imageData, 0, 0);
}

/**
 * Computes a random number between 0 and a specified boundary
 * @param boundary The upper boundary of the desired range
 * @returns
 */
function random(boundary) {
    return Math.floor(Math.random() * boundary);
}

function setPixel (imageData, pixel) {
	var redOffset = 0,
    greenOffset = 1,
    blueOffset = 2,
    alphaOffset = 3,
    pixelAddress;
	
	pixelAddress = pixel.row*(imageData.width*4) + pixel.column*4;
	imageData.data[pixelAddress + redOffset] = pixel.red;
	imageData.data[pixelAddress + greeOffset] = pixel.green; 
	imageData.data[pixelAddress + blueOffset] =pixel.blue;
	imageData.data[pixelAddress + alphaOffset] = pixel.alpha;
}

function getPixel (imageData, pixel) {
	var redOffset = 0,
        greenOffset = 1,
	    blueOffset = 2,
	    alphaOffset = 3,
	    pixelAddress;
	pixelAddress = pixel.row*(imageData.width*4) + pixel.column*4;
	pixel.red = imageData.data[pixelAddress + redOffset];
	pixel.green = imageData.data[pixelAddress + greeOffset];
	pixel.blue = imageData.data[pixelAddress + blueOffset];
	pixel.alpha = imageData.data[pixelAddress + alphaOffset];
}

var maxIterations = 30;

function colorChooser(n) {
	ch = Math.floor(n/maxIterations*255);
	if (n > (maxIterations/2)) {
		ch = 255 - ch;
	}
  b = Math.min(Math.floor(ch*1.7),255);
  r = Math.floor(ch*.6);
  g = Math.floor(ch*.9);
  return "rgb("+r+","+g+"," + b + ")";
}
